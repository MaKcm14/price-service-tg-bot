package tgbot

import (
	"bytes"
	"time"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"

	"github.com/MaKcm14/best-price-service/price-service-tg-bot/internal/entities/dto"
)

// start is the action on the /start command.
func (t *TgBot) start(chatID int64) {
	if _, flagExist := t.botConf.users[chatID]; !flagExist {
		t.botConf.users[chatID] = newUserConfig()
	}

	t.botConf.users[chatID].lastAction = startAction

	greets := []string{
		"*–ü—Ä–∏–≤–µ—Ç, –º–µ–Ω—è –∑–æ–≤—É—Ç –°–∫—Ä—É–¥–∂, –∏ —è –æ—á–µ–Ω—å –ª—é–±–ª—é —ç–∫–æ–Ω–æ–º–∏—Ç—å –≤—Ä–µ–º—è –ª—é–¥–µ–π!* ü¶Ü\n\n",
		"üìù*–ù–µ–º–Ω–æ–≥–æ –æ–±–æ –º–Ω–µ*\n–Ø –±–æ—Ç, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–º–æ–∂–µ—Ç —Ç–µ–±–µ –Ω–∞–π—Ç–∏ –æ–ø—Ç–∏–º–∞–ª—å–Ω—É—é —Ü–µ–Ω—É –Ω–∞ –Ω—É–∂–Ω—ã–π —Ç–æ–≤–∞—Ä üõí\n\n",
		"*–ß—Ç–æ–±—ã –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –º–æ–∏–º–∏ —Ñ—É–Ω–∫—Ü–∏—è–º–∏ –ø–µ—Ä–µ—Ö–æ–¥–∏ –≤ –º–µ–Ω—é üëá*",
	}

	buffer := bytes.Buffer{}

	for _, greet := range greets {
		buffer.WriteString(greet)
	}

	t.userInteractor.IdentifyUser(chatID)

	keyboardStart := tgbotapi.NewInlineKeyboardMarkup(tgbotapi.NewInlineKeyboardRow(
		tgbotapi.NewInlineKeyboardButtonData("–ú–µ–Ω—é üìã", menuAction),
	))
	message := tgbotapi.NewMessage(chatID, buffer.String())

	message.ParseMode = markDown
	message.ReplyMarkup = keyboardStart

	t.botConf.bot.Send(message)
}

// menu is the action on the /menu command or pressing the menu-button.
func (t *TgBot) menu(chatID int64) {
	if _, flagExist := t.botConf.users[chatID]; !flagExist {
		t.botConf.users[chatID] = newUserConfig()
	}

	t.botConf.users[chatID].lastAction = menuAction
	t.botConf.users[chatID].request = dto.ProductRequest{}

	menu := []string{
		"*–í–æ—Ç, —Å —á–µ–º —è –º–æ–≥—É —Ç–µ–±–µ –ø–æ–º–æ—á—å:*\n\n",
		"‚úî*Best price*\n",
		"- –Ω–∞–π—Ç–∏ —Ç–æ–≤–∞—Ä—ã –ø–æ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π —Ü–µ–Ω–µ (—Å–∞–º—ã–µ –¥–µ—à–µ–≤—ã–µ) üìâ\n\n",
		"‚úî*–ò–∑–±—Ä–∞–Ω–Ω–æ–µ:*\n",
		"- –≤–µ—Å—Ç–∏ –∏–∑–±—Ä–∞–Ω–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã ‚≠ê\n\n",
		"‚úî*–û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã–µ —Ç–æ–≤–∞—Ä—ã:*\n",
		"- –≤–µ—Å—Ç–∏ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–æ–≤ üîî\n\n",
		"*–í—ã–±–µ—Ä–∏ —Ä–µ–∂–∏–º, –Ω–∞–ø–∏—à–∏ –∑–∞–ø—Ä–æ—Å –¥–ª—è —Ç–æ–≤–∞—Ä–∞, –∞ —è –ø–æ–¥–±–µ—Ä—É –æ–ø—Ç–∏–º–∞–ª—å–Ω—É—é —Ü–µ–Ω—É –¥–ª—è –Ω–µ–≥–æ: –±—ã—Å—Ç—Ä–æ –∏ –≤—ã–≥–æ–¥–Ω–æ* üí≤",
	}

	keyboardMenu := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(tgbotapi.NewInlineKeyboardButtonData("Best price üìâ", bestPriceModeData)),
		tgbotapi.NewInlineKeyboardRow(tgbotapi.NewInlineKeyboardButtonData("–ò–∑–±—Ä–∞–Ω–Ω–æ–µ ‚≠ê", favoriteModeData)),
		tgbotapi.NewInlineKeyboardRow(tgbotapi.NewInlineKeyboardButtonData("–û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º—ã–µ —Ç–æ–≤–∞—Ä—ã üîî", trackedModeData)),
	)

	buffer := bytes.Buffer{}

	for _, opt := range menu {
		buffer.WriteString(opt)
	}

	message := tgbotapi.NewMessage(chatID, buffer.String())

	message.ParseMode = markDown
	message.ReplyMarkup = keyboardMenu

	t.botConf.bot.Send(message)

	t.botConf.users[chatID].favorites = newUserFavoritesConfig()
}

func (t *TgBot) showTrackedProduct(chatID int64) {
	iterInstrs := []string{
		"*ü¶Ü –Ø –≤–µ—Ä–Ω—É–ª—Å—è —Å —Ö–æ—Ä–æ—à–∏–º–∏ –Ω–æ–≤–æ—Å—Ç—è–º–∏!* üòä\n\n",
		"*–¢–≤–æ–π –æ—Ç—Å–ª–µ–∂–∏–≤–∞–º—ã–π —Ç–æ–≤–∞—Ä –ø–æ–ª—É—á–µ–Ω!*",
		"‚ùì*–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–æ–∏—Å–∫?*\n",
		"‚úî –ù–∞–∂–∏–º–∞–π –Ω–∞ —Ç–æ—Ç –º–∞—Ä–∫–µ—Ç, —Ç–æ–≤–∞—Ä –∫–æ—Ç–æ—Ä–æ–≥–æ —Ö–æ—á–µ—à—å –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å\n",
		"‚úî –ï—Å–ª–∏ —Ö–æ—á–µ—à—å –¥–æ–±–∞–≤–∏—Ç—å —Ç–æ–≤–∞—Ä –≤ –ò–∑–±—Ä–∞–Ω–Ω–æ–µ, –Ω–∞–∂–º–∏ –Ω–∞ –∫–Ω–æ–ø–∫—É\n",
		"*–î–∞–≤–∞–π —Å–º–æ—Ç—Ä–µ—Ç—å!* üëá",
	}

	buffer := bytes.Buffer{}

	for _, instruct := range iterInstrs {
		buffer.WriteString(instruct)
	}

	keyboard := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(tgbotapi.NewInlineKeyboardButtonData("–°–º–æ—Ç—Ä–µ—Ç—å —Ç–æ–≤–∞—Ä—ã üì¶", productsIter)),
		tgbotapi.NewInlineKeyboardRow(tgbotapi.NewInlineKeyboardButtonData("–ú–µ–Ω—é üìã", menuAction)),
	)

	message := tgbotapi.NewMessage(chatID, buffer.String())

	message.ParseMode = markDown
	message.ReplyMarkup = keyboard

	t.botConf.bot.Send(message)
}

// readTrackedProducts reads the tracked products from the chan connected with the kafka's consumer.
func (t *TgBot) readTrackedProducts() {
	for products := range t.trackedProds {
		if _, flagExist := t.botConf.users[products.ChatID]; !flagExist {
			t.botConf.users[products.ChatID] = newUserConfig()
		}

		for t.botConf.users[products.ChatID].lastAction == showRequest {
			continue
		}

		t.botConf.users[products.ChatID].sample.sample = products.Response.Sample

		markets := make(map[string]int)

		for _, market := range t.botConf.users[products.ChatID].request.Markets {
			markets[market] = 0
		}

		t.botConf.users[products.ChatID].sample.samplePtr = markets

		t.showTrackedProduct(products.ChatID)

		time.Sleep(time.Minute * 1)
	}
}
